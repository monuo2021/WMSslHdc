我们可以通过一个简单的实例，逐步分析这一部分代码的执行过程，理解它在不同阈值下如何计算真阳性 (TP) 和假阳性 (FP)。

### 假设：
- `known = [0.2, 0.5, 0.7, 0.9]` （已知类的分数，从低到高排序）
- `novel = [0.1, 0.3, 0.6, 0.8]` （新类的分数，从低到高排序）

这样：
- `num_k = 4`（已知类的数量）
- `num_n = 4`（新类的数量）

### 初始化：
- `tp[stype]` 和 `fp[stype]` 的长度是 `num_k + num_n + 1 = 9`。
- 初始化 `tp[stype][0] = num_k = 4` 表示所有已知类样本最初都被正确识别（所有已知样本为正）。
- 初始化 `fp[stype][0] = num_n = 4` 表示所有新类样本最初都被错误识别为正样本（假阳性为最大值）。

### 遍历 known 和 novel 分数

代码按升序比较 `novel` 和 `known` 的分数，通过递增阈值更新 TP 和 FP。我们会追踪并更新 `tp[stype]` 和 `fp[stype]`。

#### 步骤 1 (`l = 0`):
- `known[k] = 0.2`
- `novel[n] = 0.1`
- `novel[n] < known[k]`，因此增加 `n`（新类样本判断为负），减少假阳性计数：

    ```python
    n += 1  # n 变为 1
    tp[stype][1] = tp[stype][0]  # 保持 tp 不变：4
    fp[stype][1] = fp[stype][0] - 1  # 减少 fp：4 - 1 = 3
    ```
  **结果**：`tp[stype] = [4, 4, -1, -1, -1, -1, -1, -1, -1]`，`fp[stype] = [4, 3, -1, -1, -1, -1, -1, -1, -1]`

#### 步骤 2 (`l = 1`):
- `known[k] = 0.2`
- `novel[n] = 0.3`
- `novel[n] > known[k]`，因此增加 `k`（已知类样本判断为负），减少真阳性计数：

    ```python
    k += 1  # k 变为 1
    tp[stype][2] = tp[stype][1] - 1  # 减少 tp：4 - 1 = 3
    fp[stype][2] = fp[stype][1]  # 保持 fp 不变：3
    ```
  **结果**：`tp[stype] = [4, 4, 3, -1, -1, -1, -1, -1, -1]`，`fp[stype] = [4, 3, 3, -1, -1, -1, -1, -1, -1]`

#### 步骤 3 (`l = 2`):
- `known[k] = 0.5`
- `novel[n] = 0.3`
- `novel[n] < known[k]`，因此增加 `n`，减少假阳性计数：

    ```python
    n += 1  # n 变为 2
    tp[stype][3] = tp[stype][2]  # 保持 tp 不变：3
    fp[stype][3] = fp[stype][2] - 1  # 减少 fp：3 - 1 = 2
    ```
  **结果**：`tp[stype] = [4, 4, 3, 3, -1, -1, -1, -1, -1]`，`fp[stype] = [4, 3, 3, 2, -1, -1, -1, -1, -1]`

#### 步骤 4 (`l = 3`):
- `known[k] = 0.5`
- `novel[n] = 0.6`
- `novel[n] > known[k]`，因此增加 `k`，减少真阳性计数：

    ```python
    k += 1  # k 变为 2
    tp[stype][4] = tp[stype][3] - 1  # 减少 tp：3 - 1 = 2
    fp[stype][4] = fp[stype][3]  # 保持 fp 不变：2
    ```
  **结果**：`tp[stype] = [4, 4, 3, 3, 2, -1, -1, -1, -1]`，`fp[stype] = [4, 3, 3, 2, 2, -1, -1, -1, -1]`

#### 步骤 5 (`l = 4`):
- `known[k] = 0.7`
- `novel[n] = 0.6`
- `novel[n] < known[k]`，因此增加 `n`，减少假阳性计数：

    ```python
    n += 1  # n 变为 3
    tp[stype][5] = tp[stype][4]  # 保持 tp 不变：2
    fp[stype][5] = fp[stype][4] - 1  # 减少 fp：2 - 1 = 1
    ```
  **结果**：`tp[stype] = [4, 4, 3, 3, 2, 2, -1, -1, -1]`，`fp[stype] = [4, 3, 3, 2, 2, 1, -1, -1, -1]`

#### 步骤 6 (`l = 5`):
- `known[k] = 0.7`
- `novel[n] = 0.8`
- `novel[n] > known[k]`，因此增加 `k`，减少真阳性计数：

    ```python
    k += 1  # k 变为 3
    tp[stype][6] = tp[stype][5] - 1  # 减少 tp：2 - 1 = 1
    fp[stype][6] = fp[stype][5]  # 保持 fp 不变：1
    ```
  **结果**：`tp[stype] = [4, 4, 3, 3, 2, 2, 1, -1, -1]`，`fp[stype] = [4, 3, 3, 2, 2, 1, 1, -1, -1]`

#### 步骤 7 (`l = 6`):
- `known[k] = 0.9`
- `novel[n] = 0.8`
- `novel[n] < known[k]`，因此增加 `n`，减少假阳性计数：

    ```python
    n += 1  # n 变为 4
    tp[stype][7] = tp[stype][6]  # 保持 tp 不变：1
    fp[stype][7] = fp[stype][6] - 1  # 减少 fp：1 - 1 = 0
    ```
  **结果**：`tp[stype] = [4, 4, 3, 3, 2, 2, 1, 1, -1]`，`fp[stype] = [4, 3, 3, 2, 2, 1, 1, 0, -1]`

#### 步骤 8 (`l = 7`):
- `known[k] = 0.9`
- `novel` 已无剩余元素 (`n == num_n`)。
- `tp[stype][8]` 递减至 0，而 `fp[stype][8]` 保持为 0：

    ```python
    tp[stype][8:] = np.arange(tp[stype][7]-1, -1, -1)  # [0]
    fp[stype][8:] = fp[stype][7]  # 保持 fp 不变：0
    ```
  **最终结果**：`tp[stype] = [4, 4, 3, 3, 2, 2, 1, 1, 0]`，`fp[stype] = [4, 3, 3, 2, 2, 1, 1, 0, 0]`

### 总结
通过对比 `known` 和 `novel` 的排序，这段代码模拟了以不同阈值区分已知类和新类时，模型在这些阈值下的真阳性率 (TP) 和假阳性率 (FP) 的变化情况。这种处理使得在不同的排序点，我们都能获取到当前情况下的 `TP` 和 `FP` 值，从而为接下来计算 `TNR`、`AUROC` 等指标提供依据。

以下是代码的处理总结：

1. **初始状态**：假定在最低阈值下，所有的已知样本都被认为是真阳性 (TP = `num_k`)，所有新样本被认为是假阳性 (FP = `num_n`)。
  
2. **阈值递增过程**：按顺序遍历 `known` 和 `novel` 中的分数，通过递增阈值进行样本筛选。
   - 如果当前 `novel` 的分数小于 `known`，意味着新的类被排除在阈值之外，这时 `n` 增加并减少假阳性 (FP)。
   - 如果 `known` 的分数小于或等于 `novel`，已知类被排除在阈值之外，`k` 增加并减少真阳性 (TP)。

3. **结束处理**：如果遍历完 `known` 或 `novel` 之一时，剩余的元素将不再改变，所以将当前的 TP 或 FP 递减填充至末尾。

### 示例输出结果

通过这个过程，我们得到 `tp` 和 `fp` 的序列。例如：

- `tp[stype] = [4, 4, 3, 3, 2, 2, 1, 1, 0]`，表示真阳性的逐步减少。
- `fp[stype] = [4, 3, 3, 2, 2, 1, 1, 0, 0]`，表示假阳性的逐步减少。

### 下一步计算指标

基于 `tp` 和 `fp`，可以计算 `TNR` (在 TPR 为 0.95 时的 TNR)、`AUROC`、`DTACC` 等指标，通过分析不同阈值下模型区分已知类和新类的表现。这种方法有效地模拟了模型在不同阈值下的分类效果，用于评估模型的鲁棒性和 OOD 检测能力。